/**
 * Buddi Sketch, V 1.0
 * Compatible with Arduino Nano 33 BLE
 * 
 * (c) Cedric-Pascal Sommer, 2023
*/

/**
 * MANDATORY TODO SECTION
 * TODO: Need to implement logic of having other people joined over internet (Could potentially just control them with different buttons for the moment and then add internet later, just to fix bugs that exist in current version)
*/

/**
 * OPTIONAL TODO SECTION
 * TODO: Do we still need the room locations for walking if we let users sub-step / walk freely wherever they want to move?
 * TODO: Arrange more object oriented, create separate classes for objects (Room, should have background, foreground...Character, should have avatar, actionPlaying, etc...)
 * TODO: Add floating messages tags, like "Dishi sends you flowers, etc" or like a broadcast (maybe just for accessibility)
*/

/**
 * INCLUDE LIBRARY & DEFINITION SECTION
*/
// Include relevant libraries for the SSD1306-driven OLED display
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// Define OLED display configuration
#define SCREEN_WIDTH 128 // display width, in pixels
#define SCREEN_HEIGHT 64 // display height, in pixels
#define OLED_RESET -1 // reset pin or -1, for Arduino pin
#define SCREEN_ADDRESS 0x3C // display I2C address
#define CHARS_PER_BITMAP 1024 // number of chars in PROGMEM per bitmap image
#define COLOR_MODE WHITE // color theme of the on-screen objects
#define COLOR_HIGHLIGHT BLACK // color highlight color for important information

const int LEFT_BUTTON = 0; // define left button
const int MIDDLE_BUTTON = 0; // define middle button
const int RIGHT_BUTTON = 0; // define right button

/**
 * BITMAP (IMAGE) DECLARATION SECTION
*/
// 'tama0', 128x64px
unsigned char epd_bitmap_tama0[CHARS_PER_BITMAP] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xdf, 0x7e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x9e, 0xcf, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x9e, 0x7f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x9d, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x9e, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x9d, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0xdc, 0x7f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0x1b, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xa0, 0x7f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x9e, 0x9f, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x7e, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xaa, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0x80, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
// 'tama1', 128x64px
unsigned char epd_bitmap_tama1[CHARS_PER_BITMAP] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xdf, 0x7e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x9e, 0xdf, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x9e, 0x5f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x9d, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x9e, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x9d, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0xde, 0x7f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0x1f, 0x6b, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xa1, 0x6b, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x9e, 0xb7, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x7e, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xaa, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0x80, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

/**
 * CONSTANT DECLARATION SECTION
*/
// Create OLED display object with given constraints
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Create game constants
const int nAxes = 2; // Number of axes to fully describe a location, here 2 (room number and location in the room)
const int nRooms = 3; // Number of rooms (0 = left office, 1 = right office, 2 = garden)
const unsigned char* roomBackgrounds[nRooms] = {epd_bitmap_tama0, epd_bitmap_tama0, epd_bitmap_tama0}; // Define backgrounds for each room (drawn behind player), because these are actually pointers at this point
const unsigned char* roomForegrounds[nRooms] = {epd_bitmap_tama0, epd_bitmap_tama0, epd_bitmap_tama0}; // Define foregrounds for each room (drawn on top of player), because these are actually pointers at this point

const int nLocsPerRoom = 3; // Number of distinct player locations you can walk to per room (0 = left, 1 = middle, 2 = right, per each room)
const int roomWidth = SCREEN_WIDTH; // Width of a room frame
const int roomHeight = SCREEN_HEIGHT; // Heigth of a room frame
const int playerRoomLocs[nRooms][nLocsPerRoom] = {{10, 20, 30}, {10, 20, 30}, {10, 20, 30}}; // x locations player can walk to
const int othersRoomLocs[nRooms][nLocsPerRoom] = {{10, 20, 30}, {10, 20, 30}, {10, 20, 30}}; // x locations other players are spawned at or presented in
const int othersRoomLocsOffset = -10; // x offset each other player at same location is added at

const int nAvatars = 4; // Number of avatars possible in the game
const int playerAvatarYOffset = 0; // Offset in frame from y axis of own player
const int othersAvatarYOffset = 10; // Offset in frame from y axis of other players
const int avatarWidth = 42; // Width of an avatar frame
const int avatarHeigth = 42; // Height of an avatar frame
const unsigned char* allAvatars[nAvatars] = {epd_bitmap_tama0, epd_bitmap_tama0, epd_bitmap_tama0, epd_bitmap_tama0}; // Base avatar characters

const int animationSpeed = 50; // Screen is refreshed every x milliseconds (implemented as a delay at the end of the main loop)
const short frameSpeed = 0.1; // Relative frame speed (sub-stepping of animation speed), so every loop, the frame counter is increased by x. This makes it possible to advance the frame counter slowly while allowing for faster animations (like walking or not blocking the menu)
const short walkingSpeed = 0.1; // Relative walking speed while holding down button
const int nFrames = 2; // Number of frames an animation consists of
const int nAnimations = 2; // Number of animations implemented in current version
const int nMaxRepetitions = 3; // How many times non-repetitive animations are being repeated
const unsigned char* workingAnimation[nAvatars][nFrames] = {{epd_bitmap_tama0, epd_bitmap_tama0},{epd_bitmap_tama0, epd_bitmap_tama0},{epd_bitmap_tama0, epd_bitmap_tama0},{epd_bitmap_tama0, epd_bitmap_tama0}}; // Frames of working animation of all avatars
const unsigned char* flowersAnimation[nAvatars][nFrames] = {{epd_bitmap_tama0, epd_bitmap_tama0},{epd_bitmap_tama0, epd_bitmap_tama0},{epd_bitmap_tama0, epd_bitmap_tama0},{epd_bitmap_tama0, epd_bitmap_tama0}}; // Frames of giving flowers animation of all avatars
const unsigned char* (*allAnimations[nAnimations])[nAvatars][nFrames] = {&workingAnimation, &flowersAnimation}; // Animation look up array
const bool repeatTypeAnimations[nAnimations] = {true, false}; // Whether the type of animation is a repeat one or execute once

const int nMaxOthers = 3; // Maximum number of other players
const int nMaxOthersPerLoc = 3; // Maximum number of other players per location

const int nameWidth = 24; // Width of the name initials rectangle above characters' heads
const int nameHeight = 24; // Height of the name initials rectangle above characters' heads

const int nActionMenuItemLabels = 3; // Total number of menu items in the action menu
const String actionMenuItemLabels[nActionMenuItemLabels] = {"Work", "Give Flowers", "Cancel"}; // String labels for each action item
const int actionMenuItemLabelHeight = 32; // Number of pixels each action item is high
const int actionMenuItemLabelMargin = 4; // Margin to the screen for each action menu item
const int actionMenuItemLabelFontSize = 1; // Font size for the label

/**
 * VARIABLE DECLARATION SECTION
*/
int imgSelector = 0; /// TODO: To be removed
bool currentPause = false; // Whether the player is currently in the start screen or in an active session

int currentFrame = 0; // Counts what animation frame is currently presented, increases after every frame
int currentPlayerAnimationRepeatCounter = 0; // Counts how many times the current animation has already been repeated for this player
int currentOthersAnimationRepeatCounter[nMaxOthers] = {0, 0, 0}; // Counts how many times the current animation has already been repeated for other players

int nCurrentOthers = 0; // Number of other players joined
int currentPlayerLoc[nAxes] = {0, 0}; // Which room the player is currently in. Possible values are 0 (left office), 1 (right office), 2 (garden)
int currentOthersLocs[nMaxOthers][nAxes] = {{0, 0}, {0, 0}, {0, 0}};

int currentPlayerAvatar = 0; // Which avatar the player has currently selected
int currentOthersAvatars[nMaxOthers] = {0, 0, 0}; // Which avatars the other players have selected

String currentPlayerName = ""; // Name initials of the current player
String currentOthersNames[nMaxOthers] = {"", "", ""}; // Name initials of the current player

int currentPlayerAnimation = 0; // Which animation the player is currently executing
int currentPlayerPreviousAnimation = 0; // Which looped animation was executing before

int currentOthersAnimation[nMaxOthers] = {0, 0, 0}; // Which animation the other players are executing at the moment
int currentOthersPreviousAnimation[nMaxOthers] = {0, 0, 0}; // Which non-loop animation the other players are executing before

bool currentActionMenuOpen = false; // Whether or not the menu is currently open or not (has effects on LEFT and RIGHT button functionality)
int currentActionMenuItemLabelSelected = 0; // Which option in the menu is selected from default

/**
 * SETUP FUNCTION
*/
void setup()
{

  // Launch debugging console
  Serial.begin(9600, NULL);
  
  // Try to initialize screen object under given screen address, block if unsuccessful
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {

    Serial.println("Error: Display could not be found");
    for(;;);

  }

  // Define pin modes
  pinMode(LEFT_BUTTON, INPUT_PULLUP);
  pinMode(MIDDLE_BUTTON, INPUT_PULLUP);
  pinMode(RIGHT_BUTTON, INPUT_PULLUP);

  // Clear the display and buffer
  display.clearDisplay();
  
}

/**
 * LOOP FUNCTION
*/
void loop() {

  // Clear the display and buffer
  display.clearDisplay();

  // Draw background of current room
  int currentRoom = currentPlayerLoc[0];
  int currentLoc = currentPlayerLoc[1];
  display.drawBitmap(0, 0,  roomBackgrounds[currentRoom], roomWidth, roomHeight, COLOR_MODE);

  // Draw all other characters at their respective locations into room
  for (int i = 0; i < nCurrentOthers; i++) {

    // Draw avatar only if in the current room, else skip this one
    if(!currentOthersLocs[i][0] == currentRoom) {
      continue;
    }

    int otherAvatar = currentOthersAvatars[i]; // Select other player's avatar
    int otherAvatarAnimation = currentOthersAnimation[i]; // Select other player's current animation

    // Draw other avatar with respective animation
    int otherAvatarCalculatedX = othersRoomLocs[currentRoom][currentOthersLocs[i][1]]+othersRoomLocsOffset*i;
    display.drawBitmap(otherAvatarCalculatedX, othersAvatarYOffset, (*allAnimations[otherAvatarAnimation])[otherAvatar][currentFrame], avatarWidth, avatarHeigth, COLOR_MODE);

    // Draw other name initials above the avatar in a blanc rectangle
    String otherName = currentOthersNames[i];
    display.drawRect(otherAvatarCalculatedX, othersAvatarYOffset, nameWidth, nameHeight, COLOR_HIGHLIGHT);
    display.setCursor(otherAvatarCalculatedX, othersAvatarYOffset);
    display.setTextSize(1);
    display.setTextColor(COLOR_MODE);
    display.println(otherName);

    // Determine whether animation will be repeated again or not
    bool othersAvatarAnimationRepeat = repeatTypeAnimations[otherAvatarAnimation];

    // If not repeated, increase the counter and potentially kick out animation
    if(!othersAvatarAnimationRepeat) {

      currentOthersAnimationRepeatCounter[i] += 1; // Increase non-repeat animation counter by 1
      if(currentOthersAnimationRepeatCounter[i]>=nMaxRepetitions*nFrames) {
        currentOthersAnimation[i] = currentOthersPreviousAnimation[i]; // If non-repeat animation has been repeated enough times, loop back to last repeat animation
      }

    }

    // If repeated, potentially assign this animation as he previous one to return to if anything happens
    else {

      if(currentOthersPreviousAnimation[i] != currentOthersAnimation[i]) {
        currentOthersPreviousAnimation[i] = currentOthersAnimation[i];
        currentOthersAnimationRepeatCounter[i] = 0;
      }

    }

  }

  // Draw own player's avatar with animation in current frame
  int playerAvatarCalculatedX = playerRoomLocs[currentRoom][currentLoc];
  display.drawBitmap(playerAvatarCalculatedX, playerAvatarYOffset,  (*allAnimations[currentPlayerAnimation])[currentPlayerAvatar][currentFrame], avatarWidth, avatarHeigth, COLOR_MODE);

  // Draw own player's name initials above the avatar in a blanc rectangle
  display.drawRect(playerAvatarCalculatedX, playerAvatarYOffset, nameWidth, nameHeight, COLOR_HIGHLIGHT);
  display.setCursor(playerAvatarCalculatedX, playerAvatarYOffset);
  display.setTextSize(1);
  display.setTextColor(COLOR_MODE);
  display.println(currentPlayerName);

  // Determine whether animation will be repeated again or not
  bool playerAvatarAnimationRepeat = repeatTypeAnimations[currentPlayerAnimation];

  // If not repeated, increase the counter and potentially kick out animation
  if(!playerAvatarAnimationRepeat) {

    currentPlayerAnimationRepeatCounter += 1; // Increase non-repeat animation counter by 1
    if(currentPlayerAnimationRepeatCounter>=nMaxRepetitions*nFrames) {
      currentPlayerAnimation = currentPlayerPreviousAnimation; // If non-repeat animation has been repeated enough times, loop back to default animation
    }

  }

  // If repeated, potentially assign this animation as he previous one to return to if anything happens
  else {

    if(currentPlayerPreviousAnimation != currentPlayerAnimation) {
      currentPlayerPreviousAnimation = currentPlayerAnimation;
      currentPlayerAnimationRepeatCounter = 0;
    }

  }

  // Draw foreground of current room
  display.drawBitmap(0, 0,  roomForegrounds[currentRoom], roomWidth, roomHeight, COLOR_MODE);
  
  // Draw section for or action menu
  if(currentActionMenuOpen) {

    // Draw the action menu rectangle
    display.drawRect(0, 0, SCREEN_WIDTH, actionMenuItemLabelHeight*nActionMenuItemLabels, COLOR_MODE);
    
    for(int i = 0; i < nActionMenuItemLabels; i++) {
      
      display.setCursor(actionMenuItemLabelMargin, actionMenuItemLabelMargin);
      display.setTextSize(actionMenuItemLabelFontSize);
      
      // If this menu item is currently selected, highlight it
      if(currentActionMenuItemLabelSelected == i) {
        display.setTextColor(COLOR_HIGHLIGHT);
      }

      // Otherwise, just keep it as it is
      else {
        display.setTextColor(COLOR_MODE);
      }
      
      // Draw the action menu item
      display.println(actionMenuItemLabels[i]);

    }

  }

  // Check if any buttons are currently pressed
  int leftButtonPressed = digitalRead(LEFT_BUTTON);
  int middleButtonPressed = digitalRead(MIDDLE_BUTTON);
  int rightButtonPressed = digitalRead(RIGHT_BUTTON);

  // If action menu is currently open, the following will be checked to determine button interpretation
  if(currentActionMenuOpen) {

    // Execute action if middle button pressed
    if(middleButtonPressed == LOW) {
      currentPlayerAnimation = currentActionMenuItemLabelSelected;
      currentActionMenuOpen = false;
    }

    // Move to next or previous menu item if side buttons pressed
    else if(leftButtonPressed == LOW) {
      currentActionMenuItemLabelSelected-=1;
    }

    else if(rightButtonPressed == LOW) {
      currentActionMenuItemLabelSelected+=1;
    }

  }

  // Otherwise, the following will be checked to interpret button clicks
  else {

    // Open menu if middle button pressed
    if(middleButtonPressed == LOW) {
      currentActionMenuOpen = true;
    }

    // Move to next or previous location if side buttons pressed
    else if(leftButtonPressed == LOW) {
      currentPlayerLoc[1]-=walkingSpeed;
    }

    else if(rightButtonPressed == LOW) {
      currentPlayerLoc[1]+=walkingSpeed;
    }

  }

  // Display current frame
  display.display();
  delay(animationSpeed);

  // Fix outside bounds for player location
  if(currentPlayerLoc[1] >= nLocsPerRoom) {
    currentPlayerLoc[0]+=1;
    currentPlayerLoc[1] = 0;
  }

  else if(currentPlayerLoc[1] < 0) {
    currentPlayerLoc[0]-=1;
    currentPlayerLoc[1] = nLocsPerRoom-1;
  }

  // Fix outside bounds for player room
  if(currentPlayerLoc[0] >= nRooms) {
    currentPlayerLoc[0] = nRooms-1;
  }

  else if(currentPlayerLoc[0] < -1) {
    currentPlayerLoc[0] = 0;
  }

  // Fix outside bounds for menu item selected
  if(currentActionMenuItemLabelSelected >= nActionMenuItemLabels) {
    currentActionMenuItemLabelSelected = 0;
  }

  else if(currentActionMenuItemLabelSelected < 0) {
    currentActionMenuItemLabelSelected = nActionMenuItemLabels-1;
  }

  // Increase to next animation frame for next loop cycle (and reset if beyond the maximum frame number)  
  currentFrame+=frameSpeed;

  if(currentFrame>=nFrames) {
    currentFrame = 0;
  }
  
}