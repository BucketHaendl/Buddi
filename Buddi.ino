/**
 * Buddi Sketch, V 1.0
 * Compatible with Arduino Nano 33 BLE
 * 
 * (c) Cedric-Pascal Sommer, 2023
*/

/**
 * MANDATORY TODO SECTION
 * TODO: Need to implement logic of having other people joined over internet (Could potentially just control them with different buttons for the moment and then add internet later, just to fix bugs that exist in current version)
 * TODO: Use scheduler and yield() to run network, buttons (user interface) and screen update in parallel
 */

/**
 * DESIGN TODO SECTION
 * TODO: Change avatar size to 42x42 (instead of full screen)
 * TODO: Enable character rendering again
 * TODO: Enable character rendering of other characters again
 * TODO: Enable background rendering again
 * TODO: Enable foreground rendering again
 * TOOD: Remove rotary encoder, unless I want to use it instead of buttons, and change button pin definitions
*/

/**
 * OPTIONAL TODO SECTION
 * TODO: No network connection error screen & handling...just you yourself appears & you can reset?...or just a network connection screen at beginning
 * TODO: Error / abort display when setup fails and ask to reset
 * TODO: Maybe implement that we can controll the other characters
 * TODO: Also implement high five and ducking with joystick (just for fun)
 * TODO: Arrange more object oriented, create separate classes for objects (Room, should have background, foreground...Character, should have avatar, actionPlaying, etc...)
 * TODO: Add floating messages tags, like "Dishi sends you flowers, etc" or like a broadcast (maybe just for accessibility)
*/

/**
 * INCLUDE LIBRARY & DEFINITION SECTION
*/
// Include relevant libraries for the SSD1306-driven OLED display
#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// Define OLED display configuration
#define SCREEN_WIDTH 128 // display width, in pixels
#define SCREEN_HEIGHT 64 // display height, in pixels
#define OLED_RESET -1 // reset pin or -1, for Arduino pin
#define SCREEN_ADDRESS 0x3C // display I2C address
#define CHARS_PER_BITMAP 1024 // number of chars in PROGMEM per bitmap image
#define COLOR_MODE WHITE // color theme of the on-screen objects
#define COLOR_HIGHLIGHT BLACK // color highlight color for important information
#define BITMAP_COLOR WHITE // background color of the bitmaps

#define LEFT_BUTTON A0 // define left button
#define MIDDLE_BUTTON A0 // define middle button
#define RIGHT_BUTTON A0 // define right button

#define VRX A1 // Pin for rotary encoder, CLK pin
#define VRY A2 // Pin for rotary encoder, DT pin
#define SW A3 // Pin for rotary encoder, SW pin

/**
 * BITMAP (IMAGE) DECLARATION SECTION
*/
// 'tama0', 128x64px
unsigned char epd_bitmap_tama0[CHARS_PER_BITMAP] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xdf, 0x7e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x9e, 0xcf, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x9e, 0x7f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x9d, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x9e, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x9d, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0xdc, 0x7f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0x1b, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xa0, 0x7f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x9e, 0x9f, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x7e, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xaa, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0x80, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
// 'tama1', 128x64px
unsigned char epd_bitmap_tama1[CHARS_PER_BITMAP] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xdf, 0x7e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x9e, 0xdf, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x9e, 0x5f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x9d, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x9e, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x9d, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0xde, 0x7f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0x1f, 0x6b, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xa1, 0x6b, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x9e, 0xb7, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x7e, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xaa, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0x80, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

/**
 * CONSTANT DECLARATION SECTION
*/
// Create joystick constants
const int LEFT_THRESHOLD = 200;
const int RIGHT_THRESHOLD = 800;

// Create game constants
const int leftFOV = (int) SCREEN_WIDTH*0.3; // Left threshhold of character position, before the background scrolls
const int rightFOV = (int) SCREEN_WIDTH*0.7; // Right threshhold of character position, before the background scrolls
const float parallaxFactor = 0.5; // Factor by which the frame scroll (parallax) of the background will be slowed down.

const int nAxes = 2; // Number of axes to fully describe a location, here 2 (room number and real location in the room)
const int nRooms = 3; // Number of rooms (0 = left office, 1 = right office, 2 = garden)
const int roomSizes[nRooms] = {200, 200, 200}; // Sizes (x-dimensions) of rooms, for parallax scrolling across the background (use sizes larger than the screen size)
const unsigned char* roomBackgrounds[nRooms] = {epd_bitmap_tama0, epd_bitmap_tama0, epd_bitmap_tama0}; // Define backgrounds for each room (drawn behind player), because these are actually pointers at this point
const unsigned char* roomForegrounds[nRooms] = {epd_bitmap_tama0, epd_bitmap_tama0, epd_bitmap_tama0}; // Define foregrounds for each room (drawn on top of player), because these are actually pointers at this point

const int roomWidth = SCREEN_WIDTH; // Width of a room frame
const int roomHeight = SCREEN_HEIGHT; // Heigth of a room frame
const int nameWidth = 20; // Width of the name
const int othersRoomLocsOffset = -10; // x offset each other player at same location is added at

const int nAvatars = 4; // Number of avatars possible in the game
const int playerAvatarYOffset = 0; // Offset in frame from y axis of own player
const int othersAvatarYOffset = 10; // Offset in frame from y axis of other players
const int avatarWidth = 128; // Width of an avatar frame
const int avatarHeigth = 64; // Height of an avatar frame
const unsigned char* allAvatars[nAvatars] = {epd_bitmap_tama0, epd_bitmap_tama0, epd_bitmap_tama0, epd_bitmap_tama0}; // Base avatar characters

const int animationSpeed = 50; // Screen is refreshed every x milliseconds (implemented as a delay at the end of the main loop)
const float frameSpeed = 0.1; // Relative frame speed (sub-stepping of animation speed), so every loop, the frame counter is increased by x. This makes it possible to advance the frame counter slowly while allowing for faster animations (like walking or not blocking the menu)
const float walkingSpeed = 4; // Relative walking speed while holding down button. NOTE: walkingSpeed*parallaxFactor MUST be a full (int) number
const int nFrames = 2; // Number of frames an animation consists of
const int nAnimations = 2; // Number of animations implemented in current version
const int nMaxRepetitions = 3; // How many times non-repetitive animations are being repeated
const unsigned char* workingAnimation[nAvatars][nFrames] = {{epd_bitmap_tama0, epd_bitmap_tama1},{epd_bitmap_tama0, epd_bitmap_tama1},{epd_bitmap_tama0, epd_bitmap_tama1},{epd_bitmap_tama0, epd_bitmap_tama1}}; // Frames of working animation of all avatars
const unsigned char* flowersAnimation[nAvatars][nFrames] = {{epd_bitmap_tama0, epd_bitmap_tama1},{epd_bitmap_tama0, epd_bitmap_tama1},{epd_bitmap_tama0, epd_bitmap_tama1},{epd_bitmap_tama0, epd_bitmap_tama1}}; // Frames of giving flowers animation of all avatars
const unsigned char* (*allAnimations[nAnimations])[nAvatars][nFrames] = {&workingAnimation, &flowersAnimation}; // Animation look up array
const bool repeatTypeAnimations[nAnimations] = {true, false}; // Whether the type of animation is a repeat one or execute once

const int nMaxOthers = 3; // Maximum number of other players
const int nMaxOthersPerLoc = 3; // Maximum number of other players per location

const int nActionMenuItemLabels = 3; // Total number of menu items in the action menu
const String actionMenuItemLabels[nActionMenuItemLabels] = {"Work", "Flowers", "Cancel"}; // String labels for each action item
const int actionMenuItemLabelHeight = 12; // Number of pixels each action item is high
const int actionMenuItemLabelMargin = 4; // Margin to the screen for each action menu item
const int actionMenuItemLabelFontSize = 1; // Font size for the label

/**
 * VARIABLE DECLARATION SECTION
*/
// Joystick variables
int lastButtonPress = 0;

// Create OLED display object with given constraints
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
int imgSelector = 0; /// TODO: To be removed
bool currentPause = false; // Whether the player is currently in the start screen or in an active session

float currentFrame = 0.0; // Counts what animation frame is currently presented, increases after every frame
int currentPlayerAnimationRepeatCounter = 0; // Counts how many times the current animation has already been repeated for this player
int currentOthersAnimationRepeatCounter[nMaxOthers] = {0, 0, 0}; // Counts how many times the current animation has already been repeated for other players

int nCurrentOthers = 3; // Number of other players joined
int currentPlayerLoc[nAxes] = {0, (int)(avatarWidth/2)}; // Which room the player is currently in and what his real and rendered location is. Possible values are 0 (left office), 1 (right office), 2 (garden)
int currentOthersLocs[nMaxOthers][nAxes] = {{0, 0}, {0, 20}, {0, 40}};

int currentPlayerAvatar = 0; // Which avatar the player has currently selected
int currentOthersAvatars[nMaxOthers] = {0, 0, 0}; // Which avatars the other players have selected

String currentPlayerName = "Cedi"; // Name initials of the current player
String currentOthersNames[nMaxOthers] = {"Jon", "Ana", "Dishi"}; // Name initials of the current player

int currentBackgroundLoc = 0; // Current location of the background the player is currently in (for rendering)
int currentPlayerAnimation = 0; // Which animation the player is currently executing
int currentPlayerPreviousAnimation = 0; // Which looped animation was executing before

int currentOthersAnimation[nMaxOthers] = {0, 0, 0}; // Which animation the other players are executing at the moment
int currentOthersPreviousAnimation[nMaxOthers] = {0, 0, 0}; // Which non-loop animation the other players are executing before

bool currentActionMenuOpen = false; // Whether or not the menu is currently open or not (has effects on LEFT and RIGHT button functionality)
int currentActionMenuItemLabelSelected = 0; // Which option in the menu is selected from default

/**
 * SETUP FUNCTION
*/
void setup() {

  // Launch debugging console
  Serial.begin(9600, NULL);
  
  // Try to initialize screen object under given screen address, block if unsuccessful
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {

    Serial.println("Error: Display could not be found");
    for(;;);

  }

  // Clear the display and buffer
  display.clearDisplay();

  // Set encoder pins as input pins
  pinMode(VRX, INPUT);
  pinMode(VRY, INPUT);
  pinMode(SW, INPUT_PULLUP);

  // Define pin modes
  pinMode(LEFT_BUTTON, INPUT_PULLUP);
  pinMode(MIDDLE_BUTTON, INPUT_PULLUP);
  pinMode(RIGHT_BUTTON, INPUT_PULLUP);
  
}

/**
 * LOOP FUNCTION
*/
void loop() {

  /**
   * Read button input section
  */
  // Check if any buttons are currently pressed
  int leftButtonPressed = HIGH;//digitalRead(LEFT_BUTTON);
  int middleButtonPressed = HIGH;//digitalRead(MIDDLE_BUTTON);
  int rightButtonPressed = HIGH;//digitalRead(RIGHT_BUTTON);

  if (millis() - lastButtonPress > 200) {

    // Read the y position of the joystick
    int yValue = analogRead(VRY);
    int btnState = digitalRead(SW);
    bool buttonPressed = false;

    // If walking to right
    if(yValue <= LEFT_THRESHOLD) {
      rightButtonPressed = LOW;
      buttonPressed = true;
    }

    // If walking to left
    else if(yValue >= RIGHT_THRESHOLD) {
      leftButtonPressed = LOW;
      buttonPressed = true;
    }

    // If center button pressed
    else if(btnState == LOW) {
      middleButtonPressed = LOW;
      buttonPressed = true;
    }

    // Remember last button press event
    if(buttonPressed) {
      lastButtonPress = millis();
    }

  }

  /**
   * Game output section
  */
  // Clear the display and buffer
  display.clearDisplay();

  // Draw background of current room
  int currentRoom = currentPlayerLoc[0];
  int currentLoc = currentPlayerLoc[1];
  int currentCameraLoc = -(int)(currentBackgroundLoc/parallaxFactor);

  display.drawRect(currentBackgroundLoc, 0, roomSizes[currentRoom], roomHeight, WHITE);
  //display.drawBitmap(currentBackgroundLoc, 0,  roomBackgrounds[currentRoom], roomWidth, roomHeight, BITMAP_COLOR);

  // Draw all other characters at their respective locations into room
  for (int i = 0; i < nCurrentOthers; i++) {

    // Draw avatar only if in the current room, else skip this one
    if(!currentOthersLocs[i][0] == currentRoom) {
      continue;
    }

    int otherAvatar = currentOthersAvatars[i]; // Select other player's avatar
    int otherAvatarAnimation = currentOthersAnimation[i]; // Select other player's current animation

    // Draw other avatar with respective animation
    int otherAvatarRenderX = -currentCameraLoc+currentOthersLocs[i][1]-(int)(avatarWidth/2);
    //display.drawBitmap(otherAvatarRenderX, othersAvatarYOffset, (*allAnimations[otherAvatarAnimation])[otherAvatar][(int)currentFrame], avatarWidth, avatarHeigth, BITMAP_COLOR);

    // Draw other name initials above the avatar in a blanc rectangle
    String otherName = currentOthersNames[i];
    display.setCursor(otherAvatarRenderX+(int)(avatarWidth/2)+(int)(-nameWidth/2), othersAvatarYOffset);
    display.setTextSize(1);
    display.setTextWrap(false);
    display.setTextColor(WHITE, BLACK);
    display.println(otherName);

    // Determine whether animation will be repeated again or not
    bool othersAvatarAnimationRepeat = repeatTypeAnimations[otherAvatarAnimation];

    // If not repeated, increase the counter and potentially kick out animation
    if(!othersAvatarAnimationRepeat) {

      currentOthersAnimationRepeatCounter[i] += 1; // Increase non-repeat animation counter by 1
      if(currentOthersAnimationRepeatCounter[i]>=nMaxRepetitions*nFrames) {
        currentOthersAnimation[i] = currentOthersPreviousAnimation[i]; // If non-repeat animation has been repeated enough times, loop back to last repeat animation
      }

    }

    // If repeated, potentially assign this animation as he previous one to return to if anything happens
    else {

      if(currentOthersPreviousAnimation[i] != currentOthersAnimation[i]) {
        currentOthersPreviousAnimation[i] = currentOthersAnimation[i];
        currentOthersAnimationRepeatCounter[i] = 0;
      }

    }

  }

  // Draw own player's avatar with animation in current frame
  int playerAvatarRenderX = currentLoc-(int)(avatarWidth/2)-currentCameraLoc;
  //display.drawBitmap(playerAvatarRenderX, playerAvatarYOffset, (*allAnimations[currentPlayerAnimation])[currentPlayerAvatar][(int)currentFrame], avatarWidth, avatarHeigth, BITMAP_COLOR);

  // Draw own player's name initials above the avatar in a blanc rectangle
  display.setCursor(playerAvatarRenderX+(int)(avatarWidth/2)+(int)(-nameWidth/2), playerAvatarYOffset);
  display.setTextSize(1);
  display.setTextWrap(false);
  display.setTextColor(WHITE, BLACK);
  display.println(currentPlayerName);

  // Determine whether animation will be repeated again or not
  bool playerAvatarAnimationRepeat = repeatTypeAnimations[currentPlayerAnimation];

  // If not repeated, increase the counter and potentially kick out animation
  if(!playerAvatarAnimationRepeat) {

    currentPlayerAnimationRepeatCounter += 1; // Increase non-repeat animation counter by 1
    if(currentPlayerAnimationRepeatCounter>=nMaxRepetitions*nFrames) {
      currentPlayerAnimation = currentPlayerPreviousAnimation; // If non-repeat animation has been repeated enough times, loop back to default animation
    }

  }

  // If repeated, potentially assign this animation as he previous one to return to if anything happens
  else {

    if(currentPlayerPreviousAnimation != currentPlayerAnimation) {
      currentPlayerPreviousAnimation = currentPlayerAnimation;
      currentPlayerAnimationRepeatCounter = 0;
    }

  }

  // Draw foreground of current room
  display.fillRect(-currentCameraLoc+60, 44, 20, 20, BLACK);
  display.fillRect(-currentCameraLoc+150, 44, 20, 20, BLACK);
  // display.drawBitmap(0, 0,  roomForegrounds[currentRoom], roomWidth, roomHeight, BITMAP_COLOR);
  
  // Draw section for or action menu
  if(currentActionMenuOpen) {

    // Draw the action menu rectangle
    display.fillRect(0, 0, SCREEN_WIDTH, actionMenuItemLabelHeight*nActionMenuItemLabels, BLACK);
    
    for(int i = 0; i < nActionMenuItemLabels; i++) {
      
      display.setCursor(actionMenuItemLabelMargin, actionMenuItemLabelMargin+i*actionMenuItemLabelHeight);
      display.setTextSize(actionMenuItemLabelFontSize);
      
      // If this menu item is currently selected, highlight it
      if(currentActionMenuItemLabelSelected == i) {
        display.setTextColor(BLACK, WHITE);
      }

      // Otherwise, just keep it as it is
      else {
        display.setTextColor(WHITE);
      }
      
      // Draw the action menu item
      display.println(actionMenuItemLabels[i]);

    }

  }

  // If action menu is currently open, the following will be checked to determine button interpretation
  if(currentActionMenuOpen) {

    // Execute action if middle button pressed
    if(middleButtonPressed == LOW) {

      // Only change animation if not cancel (last) option was chosen
      if(currentActionMenuItemLabelSelected < nAnimations) {
        currentPlayerAnimation = currentActionMenuItemLabelSelected;
      }

      currentActionMenuOpen = false;
    }

    // Move to next or previous menu item if side buttons pressed
    else if(leftButtonPressed == LOW) {
      currentActionMenuItemLabelSelected-=1;
    }

    else if(rightButtonPressed == LOW) {
      currentActionMenuItemLabelSelected+=1;
    }

  }

  // Otherwise, the following will be checked to interpret button clicks
  else {

    // Open menu if middle button pressed
    if(middleButtonPressed == LOW) {
      currentActionMenuOpen = true;
    }

    // Move to next or previous location if side buttons pressed
    else if(leftButtonPressed == LOW) {

      // If player moving beyond left FOV, move background (parallax) layer (unless already at end of room)
      if(currentPlayerLoc[1] < leftFOV+currentCameraLoc && currentBackgroundLoc < 0) {
        currentBackgroundLoc+=(int)(walkingSpeed*parallaxFactor);
        currentPlayerLoc[1]-=walkingSpeed;
      }

      // Otherwise, move the player position left on the screen
      else {
        currentPlayerLoc[1]-=walkingSpeed;
      }

      Serial.println(currentPlayerLoc[1]);
      Serial.println(currentBackgroundLoc);
      Serial.println(currentCameraLoc);

    }

    else if(rightButtonPressed == LOW) {

      // If player moving beyond right FOV, move background (parallax) layer (unless already at end of room)
      if(currentPlayerLoc[1] > rightFOV+currentCameraLoc && currentBackgroundLoc > SCREEN_WIDTH-roomSizes[currentPlayerLoc[0]]) {
        currentBackgroundLoc-=(int)(walkingSpeed*parallaxFactor);
        currentPlayerLoc[1]+=walkingSpeed;
      }

      // Otherwise, move player position right on screen
      else {
        currentPlayerLoc[1]+=walkingSpeed;
      }

      Serial.println(currentPlayerLoc[1]);
      Serial.println(currentBackgroundLoc);
      Serial.println(currentCameraLoc);
        
    }
      
  }

  // Display current frame
  display.display();
  delay(animationSpeed);

  // Fix outside bounds for player location
  if(currentPlayerLoc[1] > 2*roomSizes[currentPlayerLoc[0]]-SCREEN_WIDTH) {
    Serial.println("Next room");
    currentPlayerLoc[0]+=1;
    currentPlayerLoc[1] = 0;
    currentBackgroundLoc = 0;
  }

  else if(currentPlayerLoc[1] < 0) {
    Serial.println("Previous room");
    currentPlayerLoc[0]-=1;
    currentPlayerLoc[1] = 2*roomSizes[currentPlayerLoc[0]]-SCREEN_WIDTH;
    currentBackgroundLoc = SCREEN_WIDTH-roomSizes[currentPlayerLoc[0]];
  }

  // Fix outside bounds for player room
  if(currentPlayerLoc[0] >= nRooms) {
    Serial.println("Already last room");
    currentPlayerLoc[0] = nRooms-1;
    currentPlayerLoc[1] = 2*roomSizes[currentPlayerLoc[0]]-SCREEN_WIDTH;
    currentBackgroundLoc = SCREEN_WIDTH-roomSizes[currentPlayerLoc[0]];
  }

  else if(currentPlayerLoc[0] < 0) {
    Serial.println("Already first room");
    currentPlayerLoc[0] = 0;
    currentPlayerLoc[1] = 0;
    currentBackgroundLoc = 0;
  }

  // Fix outside bounds for menu item selected
  if(currentActionMenuItemLabelSelected >= nActionMenuItemLabels) {
    currentActionMenuItemLabelSelected = 0;
  }

  else if(currentActionMenuItemLabelSelected < 0) {
    currentActionMenuItemLabelSelected = nActionMenuItemLabels-1;
  }

  // Increase to next animation frame for next loop cycle (and reset if beyond the maximum frame number)  
  currentFrame+=frameSpeed;

  if(currentFrame>=nFrames) {
    currentFrame = 0;
  }
  
}